------

# Go协程

> 作者：hou
------
## 1.1 Go协程调度问题

### 1.1.1 GMP调度三要素

调度系统的目标是将 Goroutines 分配到 M 上执行，而 P 是调度的核心。多个 P 可以共享一个或多个 M。

1. **G (Goroutine)**  
- 每个协程，包含了一个执行上下文（如栈、指令指针等）和一个调度状态 

2. **M (Machine)**  
- 一个操作系统线程  

3. **P (Processor)**  
- 负责管理运行时的调度队列，决定哪些 G 应该被执行  

### 1.1.2 切换

1. **主动让出**  
2. **系统调用阻塞**   
3. **时间片用完**  
4. **通道、锁操作**  

### 1.1.3 调度算法：工作窃取和自旋

1. **工作窃取**  
- Go 使用工作窃取算法来平衡不同处理器上的负载。
- 当某个 `P` 的队列空闲时，它会尝试从其他 `P` 的队列中窃取 `G`，以确保所有的 `P` 都能忙碌地工作。  
- 全局队列 在本地队列为空、新创建 Goroutine 或工作窃取失败时被调用。
- 窃取尾部 的数量通常是其他 P 本地队列的一半，但至少窃取一个。

2. **自旋锁**  
- Go 在调度器内部会使用自旋锁来防止频繁的线程上下文切换。自旋锁是为了避免因为某些协程短时间内频繁挂起和唤醒，导致性能的浪费。  

## 1.2 阻塞后上阻塞谁？阻塞结束后会干嘛

### 1.2.1 IO阻塞

1. **阻塞G，M被释放执行其他G**   
2. **G尝试重新进入调度队列，调度器找一个可用的M来执行G**   

### 1.2.2 系统调用

1. **短时间：M阻塞，P仍然绑定M**  
2. **长时间：M解绑P，交给其他M**  

## 1.3 为什么协程比较轻量

1. **快速创建/销毁**  
- 远快于传统线程，能够迅速响应并发需求。  

2. **内存占用极低**  
- 初始栈大小仅 2KB（对比线程通常 1-8MB 并且是静态分配），动态增长收缩  

3. **用户态调度（零内核开销）**  
- 线程是操作系统负责状态切换，也就是用户态和内核态  

4. **调度效率优化**  
- 使用自己的调度器（M、P、G）来管理协程  

5. **数量优势**  
- 操作系统通常可以处理的线程数量在数百到几千个之间；Go 运行时可以轻松地创建和管理成千上万的协程  

## 1.4 Go Channel

### 1.4.1 Go Channel什么时候会被用到

1. **数据传递**  
- 协程独立执行的，所以共享数据需要某种方式同步  

2. **事件通知**  
- 你希望某个事件执行完后再执行其他任务  

3. **生产消费**  
- 生产者分配任务到 channel，消费者从 channel 中接受任务进行处理  

4. **限制并发数**  
- 限制同时发起的网络请求数量  

5. **多路复用, 超时控制**  
- 定时任务，通过 `select` 语句，可以在多个 `channel` 中选择操作。  
    1. 使用time.ticker
    2. for select case<-ticker.C
    3. time.AfterFunc适合一次性延迟任务

6. **任务取消**  
- 在并发程序中，某些任务可能需要在特定条件下取消。可以通过 `channel` 来传递取消信号  

### 1.4.2 往一个已经关闭的channel写、读数据会怎么样？

1. **写数据**  
- 立即 panic  

2. **读数据**  
- 有数据正常读取；无数据返回零值  

3. **关闭已关闭的也会panic**  
- 关闭已经关闭的 channel 会 panic  

### 1.4.3 对未初始化的的chan进行读写，会怎么样
读写未初始化的chan都会阻塞。

### 1.4.4 如何判断一个channel已经关闭

1. **`value, ok := <-ch`**  
- 通过 `ok` 判断 channel 是否关闭  

2. **`for range` 遍历 `channel`**  
- 使用 `for range` 遍历 channel，当 channel 关闭时循环结束