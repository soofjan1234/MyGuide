------

# NSQ

> 作者：hou
------
## 1.1 为什么使用NSQ 
- 相较 Kafka，虽然 NSQ 在高吞吐和持久化方面略逊一筹，但我们不需要那么强的日志存储能力和分布式架构复杂性，所以选用了 NSQ
- 因为它部署简单、实时性强、延迟低、Go 支持好
- 主要根据项目规模以及吞吐量来选择

### 1.1.1 为什么选择 NSQ 而不是 Redis
1.高吞吐：Redis基于内存运行，当消息大量堆积时，需要扩容内存，成本较高；而NSQ内置了消息队列，能够处理高吞吐场景。
2.持久化：Redis的Stream功能支持消息持久化，但设计初衷并非面向高吞吐场景；而NSQ的消息默认持久化到磁盘，即使消费者离线，数据也不会丢失。
3.消费者模型：Redis的Pub/Sub模式不支持多消费者组，需要手动实现消费者组；而NSQ支持多通道（Channel），同一Topic可以被多个消费者组订阅，增强了消息处理的灵活性。
4.运维友好性：Redis需要第三方监控工具；而NSQ内置了管理界面，便于运维人员监控。

## 1.2 NSQ核心概念

1. **Topic**  
2. **Channel**  
- 消费者通过订阅特定的 Channel 来消费消息，一个 Topic 可以有多个 Channel  
- Kafka 的 Partition 更强调消息的分区存储，而 NSQ 的 Channel 更强调消息的并行消费

3. **Message**  
- 消息的基本单元，包含消息体和元数据  

4. **Producer**  
5. **Consumer**   

## 1.3 NSQ 架构

### 1.3.1 nsqd
- NSQ 的核心组件，负责接收、存储和传递消息  

**特性**:
1. **负载均衡策略** ：对订阅了同一个 Topic，同一个 Channel 的消费者使用负载均衡策略（不是轮询）  

2. **消息缓存** ：只要 Channel 存在，即使没有该 Channel 的消费者，也会将生产者的 Message 缓存到队列中  

3. **消息持久化** ：保证队列中的 Message 至少会被消费一次，即使 nsqd 退出，也会将队列中的消息暂存磁盘上（结束进程等意外情况除外）  

4. **内存管理** ：限定内存占用，能够配置 nsqd 中每个 Channel 队列在内存中缓存的 Message 数量，一旦超出，Message 将被缓存到磁盘中  

5. **资源管理** ：Topic 和 Channel 一旦建立，将会一直存在，要及时在管理台或者用代码清除无效的 Topic 和 Channel，避免资源的浪费  

### 1.3.2 nsqlookupd
- 负责管理 nsqd 的注册和发现，消费者通过 nsqlookupd 找到可用的 nsqd  

**特性**:
1. **唯一性**：在一个 NSQ 服务中只有一个 nsqlookupd 服务。当然也可以在集群中部署多个 nsqlookupd，但它们之间是没有关联的  

2. **去中心化**：即使 nsqlookupd 崩溃，也不会影响正在运行的 nsqd 服务  

3. **信息交互中间件**：充当 nsqd 和 nsqadmin 信息交互的中间件  

4. **HTTP 查询服务**：提供一个 HTTP 查询服务，给客户端定时更新 nsqd 的地址目录  

### 1.3.3 nsqadmin
- 提供 Web 界面，用于监控和管理 NSQ 集群  

## 1.4 NSQ 消息不丢失保证

1. **消息持久化**  
   - 消息被持久化到磁盘，确保在 nsqd 重启后消息不丢失  

2. **消息确认机制**  
   - NSQD（NSQ 守护进程）会向生产者返回一个 OK 标识，表示消息已成功被接收。
   - 消费者会向NSQD 返回 FIN 标识，表示消息已被成功处理，否则NSQD 会将消息重新入队，保证消息至少被传递一次 
   - 如果消息在指定时间内未被处理，nsqd 会自动将其重新放入队列，避免消息因消费者挂起而丢失  

## 1.5 NSQ 避免重复消费

1. **消息去重**  
   - 在消费者端维护一个已消费消息的缓存，通过消息的唯一标识（如 UUID、业务主键）进行去重  

2. **幂等校验**  
   - 消费消息服务做幂等校验：同一条消息无论处理多少次，结果一致。
   - 比如 Redis 的 `set`、MySQL 的主键等天然的幂等功能  

