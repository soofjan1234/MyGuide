------

# 系统优化


> 作者：hou
------
# 服务器有个api服务 发现一直timewait连接
通常表明 TCP 连接未能正常关闭，可能导致端口耗尽或性能下降

1. 确定问题现象
2. 排查原因，可能的原因有：
    - ​客户端问题​​：比如代码里没复用 HTTP 连接，每次请求都新建 TCP。
    - ​​服务端配置​​：比如没开 Keep-Alive，导致每次请求后关闭连接。
    - ​​网络设备​​：像负载均衡器或代理服务器强制断开连接。
3. 解决问题
    - 客户端优化：确保连接复用，减少连接创建和关闭次数。
    - 服务端配置：确保开启 Keep-Alive，避免频繁关闭连接。
    - 网络设备优化：调整负载均衡器或代理服务器的配置，减少连接数。
4. 监控和压测

# 出现大量 CLOSE_WAIT 状态的连接时，如何处理？
在 TCP 连接中， CLOSE_WAIT 状态是指被动关闭连接的一方在收到对方的 FIN 报文后，进入的状态。
此时，被动关闭方会回复一个 ACK 报文，然后进入 CLOSE_WAIT 状态，
等待上层应用程序决定是否关闭连接并发送 FIN 报文。

1. 应用程序未正确关闭连接
如果应用程序没有调用相应的关闭连接函数（如在 Python 中未调用 socket.close() ，在 Java 中未调用 Socket.close() ），连接就会一直处于 CLOSE_WAIT 状态

2. 业务逻辑处理异常
例如，在处理客户端请求时，服务器端程序抛出异常，而异常处理机制没有正确关闭连接

3. 资源泄露
如果应用程序在处理大量连接时，没有正确管理资源。
例如，打开了文件、数据库连接等资源，但在处理完请求后没有关闭这些资源，可能会影响应用程序关闭 TCP 连接，从而造成大量 CLOSE_WAIT 状态的连接。

4. 网络问题
5. 服务器负载过高

# 我想在分布式开发里面 生成全局唯一的标识符 你一般怎么做
1. uuid v4，适合简单唯一 ID，不要求有序
2. Snowflake，适合有序，高性能，分布式
3. 数据库自增ID+分片，适合中小规模系统，简单，但扩展性差（新增分片需调整步长）
4. Redis incr，高性能，但 ​​Redis 宕机可能导致重复​​（需持久化），适合临时性 ID（如短链、验证码）

## Snowflake
1. 优势
​​全局唯一​​：时间戳 + 机器 ID + 序列号组合，几乎不会重复。
趋势递增​​：时间戳在高位，生成的 ID 可以按时间排序。
​高性能​​：本地生成，无网络开销（比 UUID v4 更快）。
​短小精悍​​：64 位整数（比 UUID 的 128 位更省空间）

2. 内部算法
3. 潜在问题
时钟回拨：如果系统时间回拨，可能会导致 ID 重复。
机器 ID 冲突：如果机器 ID 重复，可能会导致 ID 重复。
​分布式部署：需要保证机器 ID 的唯一性，可能需要中心化管理。

# 分布式锁怎么做，考虑解决哪些问题
1. 实现方式
    - 基于数据库的锁：使用数据库的唯一索引或行锁。
    - 基于缓存的锁：使用 Redis 的 SETNX 命令。
    - 基于 Zookeeper 的锁：使用 Zookeeper 的临时节点。
2. 问题
    - 死锁：如果锁未释放，可能导致死锁。
    - 性能：锁的获取和释放操作应该尽可能高效，避免成为系统的瓶颈。
    - 可用性：缓存锁可能出现单点故障。
    - 可重入：锁的可重入性。如果需要支持可重入性，需要在锁的实现中记录客户端的信息。