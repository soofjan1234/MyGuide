------

# Redis

> 作者：hou
------

## 1.1 单进程单线程的？

Redis 是单进程单线程的，redis 利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。

## 1.2 Redis性能优化

### 1.2.1 性能优化策略

1. **使用批量操作**  
- 通过批量操作减少网络开销  

2. **大量 key 过期**  
- 采取定期删除 + 懒汉式删除策略  

3. **Bigkey**  
- 一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey  
  - **分割**：将 bigkey 分割成多个小 key  
  - **清理**：定期清理不再使用的 bigkey  
  - **采用合适的数据结构**：选择合适的数据结构存储数据  
  - **开启 lazy-free**：异步释放内存，避免阻塞主线程  

4. **Hotkey**  
- 一个 key 的访问次数比较多且明显多于其他 key 的话  
  - **读写分离**：主节点处理写请求，从节点处理读请求  
  - **使用 Redis Cluster**：将热点数据分散存储在多个 Redis 节点上  
  - **二级缓存**：hotkey 采用二级缓存的方式进行处理，将 hotkey 存放一份到 JVM 本地内存中（可以用 Caffeine）  

## 1.3 Redis缓存问题

### 1.3.1 缓存穿透

1. **问题描述**  
- 大量请求的 key 是不合理的，**根本不存在于缓存中，也不存在于数据库中**  

2. **解决方案**  
- **缓存无效 key**：将无效的 key 缓存起来，避免重复查询数据库  
- **布隆过滤器**：使用布隆过滤器过滤无效的 key  
- **接口限流**：对接口进行限流，避免大量请求直接打到数据库  

### 1.3.2 缓存击穿

1. **问题描述**  
- **热点数据**，该数据 **存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）**  

2. **解决方案**  
- **永不过期**：设置热点数据永不过期  
- **提前预热**：在缓存失效前提前预热数据  
- **加锁**：使用分布式锁避免多个请求同时查询数据库  

### 1.3.3 缓存雪崩

1. **问题描述**  
- **缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力**  

2. **解决方案**  
- **针对 Redis 服务不可用的情况**：使用 Redis 集群，多级缓存  
- **针对大量缓存同时失效的情况**：**设置随机失效时间、提前预热**  

## 1.4 Redis持久化机制

### 1.4.1 持久化机制

1. **RDB**  
- 快照式的持久化机制。定期将内存中的数据集保存到磁盘上的一个 RDB 文件中  

2. **AOF**  
- 日志式的持久化机制。将每个写操作（如 `SET`、`LPUSH` 等）追加到一个日志文件（通常是 `appendonly.aof`）
