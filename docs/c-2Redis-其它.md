------

# Redis

> 作者：hou
------

## 1.1 单进程单线程的？

Redis 是单进程单线程的，redis 利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。

## 1.2 Redis性能优化

### 1.2.1 性能优化策略

1. **使用批量操作**  
- 通过批量操作减少网络开销  

2. **大量 key 过期**  
- 采取定期删除 + 懒汉式删除策略  

3. **Bigkey**  
- 一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey  
  - **分割**：将 bigkey 分割成多个小 key  
  - **清理**：定期清理不再使用的 bigkey  
  - **采用合适的数据结构**：选择合适的数据结构存储数据  
  - **开启 lazy-free**：异步释放内存，避免阻塞主线程  

4. **Hotkey**  
- 一个 key 的访问次数比较多且明显多于其他 key 的话  
  - **读写分离**：主节点处理写请求，从节点处理读请求  
  - **使用 Redis Cluster**：将热点数据分散存储在多个 Redis 节点上  
  - **二级缓存**：hotkey 采用二级缓存的方式进行处理，将 hotkey 存放一份到 JVM 本地内存中（可以用 Caffeine）  

## 1.3 Redis缓存问题

### 1.3.1 缓存穿透

1. **问题描述**  
- 大量请求的 key 是不合理的，**根本不存在于缓存中，也不存在于数据库中**  

2. **解决方案**  
- **缓存无效 key**：将无效的 key 缓存起来，避免重复查询数据库  
- **接口限流**：对接口进行限流，避免大量请求直接打到数据库  
- **布隆过滤器**：使用布隆过滤器过滤无效的 key  
  - **原理**：位数组 + 多个哈希函数。  
  - **初始化**：  
    - 初始化一个长度为 `m` 的位数组，所有位初始为 `0`。  
  - **插入元素**：  
    - 对元素使用 `k` 个哈希函数计算位置。  
    - 将对应的 `k` 个位置的值设为 `1`。  
  - **查询元素**：  
    - 对元素使用 `k` 个哈希函数计算位置。  
    - 如果所有对应位都是 `1`，说明可能存在。  
    - 如果有任意一个位是 `0`，说明一定不存在。

### 1.3.2 缓存击穿

1. **问题描述**  
- **热点数据**，该数据 **存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）**  

2. **解决方案**  
- **永不过期**：设置热点数据永不过期  
- **提前预热**：在缓存失效前提前预热数据  
- **加锁**：使用分布式锁避免多个请求同时查询数据库  

### 1.3.3 缓存雪崩

1. **问题描述**  
- **缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力**  

2. **解决方案**  
- **针对 Redis 服务不可用的情况**：使用 Redis 集群，多级缓存  
- **针对大量缓存同时失效的情况**：设置随机失效时间、提前预热

### 1.3.4 数据一致性

1.如果删除了缓存Redis，还没有来得及写库MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。
2.如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。

1.Cache Aside（旁路缓存）策略：最常用
核心思路：
读操作：先查缓存，缓存没命中再查数据库，然后写入缓存；
写操作：更新数据库，然后删除缓存（或更新缓存
1) 先删除缓存，后更新数据库
当发生「读+写」并发时，还是存在数据不一致的情况
2) 先更新数据库，后删除缓存
加锁，同时写数据库，通常是要比读数据库的时间更长

2.Read Through（读穿）策略
核心思路：
这个策略类似于Cache-Aside，但是是自动读取
可以提高读取性能，但是可能会增加数据库的负载

3.Write Through（写穿）策略
核心思路：
所有写操作同时写入缓存和数据库；
读操作只读缓存

4.Write Behind（写回）策略
核心思路：
写入时只写缓存，并将更新加入队列；
后台异步线程定时批量刷新到数据库。

5.Refresh Ahead（提前刷新）策略
 核心思路：
缓存过期前自动更新数据，保持缓存是热的


## 1.4 Redis持久化机制

### 1.4.1 为什么需要持久化

redis基于内存，一旦宕机，数据将全部丢失。数据库的性能不如redis，导致程序响应慢。

### 1.4.2 RDB
- **工作原理**：
  - 快照式的持久化机制，定期将内存中的数据集保存到磁盘上的一个 RDB 文件中。
  - 客户端发送 BGSAVE 命令，Redis 主进程 fork 出子进程，子进程将当前内存数据写入临时文件（如 temp-1234.rdb ），写完后将临时文件重命名为 dump.rdb （原子替换）。
  - 先写入临时文件再重命名为 dump.rdb 的原因：
    - 直接操作 dump.rdb 文件，写入失败可能会导致文件损坏
    - 临时文件的写入过程是连续的，不需要频繁更新现有的 dump.rdb 文件，提高了写入效率
    - 如果 Redis 在写入临时文件时崩溃，临时文件会被自动删除，不会影响现有的 dump.rdb 文件

- **特点**：启动恢复速度快，是二进制快照文件；文件少，便于数据迁移；不够实时

### 1.4.3 AOF  
- **工作原理**：
   - 日志式的持久化机制，将每个写操作（如 `SET`、`LPUSH` 等）追加到一个日志文件（通常是 `appendonly.aof`）。
  - Redis 主线程每次处理完一个修改数据的命令时，会将该命令追加到 AOF 缓冲区（内存中）。
  - **刷盘策略**由配置项 `appendfsync` 控制：
    - `appendfsync always`：每次写命令都立即刷盘（最安全，性能最低）。
    - `appendfsync everysec`：每秒刷盘一次（默认，性能与安全性平衡）。
    - `appendfsync no`：不主动刷盘，完全由操作系统决定（性能最高，最不安全）。
- **AOF 重写（ReWrite）**：
  - 随着时间推移，AOF 文件会越来越大。为了优化：
    - **自动触发**：通过配置项 `auto-aof-rewrite-percentage` 触发。
    - **手动触发**：使用 `bgrewriteaof` 命令。
  - **重写流程**：
    - Redis 启动子进程（不阻塞主进程）。
    - 扫描内存中的键值对，以最简形式生成新的 AOF 文件（不是简单复制旧文件）。
    - 旧 AOF 文件仍在写入，Redis 维护一块差异缓冲区。
    - 重写完成后，合并差异缓冲区到新文件，替换原 `.aof` 文件。

- **特点**： 启动恢复速度慢，是追加日志文件；文件大，恢复速度慢；数据安全

### 1.4.5 混合持久化
混合持久化是指 Redis 在进行 AOF 重写时，不再从头写入一大堆命令，而是：

先将当前内存数据保存为 RDB 格式（二进制快照）；

然后将最近的写操作追加成 AOF 命令格式（命令日志）；

最终生成一个文件，前半部分是 RDB 内容，后半部分是 AOF 命令。