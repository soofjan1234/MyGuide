------

# 总体

> 作者：hou
------
## 1.1 nas

### 1.1.1 nas是什么东西

NAS 就是接在局域网上的“共享硬盘”。它让多台设备（电脑、手机等）能随时存取文件，像自己电脑里的硬盘一样方便。

1. **家庭使用** ：存储多种类型的文件，可以用多个设备访问  

2. **公司使用** ：存储重要文件，并进行权限管理  

3. **远程访问** ：在外面，如果想访问 NAS 里的文件，也可以通过穿透实现  

### 1.1.2 nas的架构

1. **客户层（Customer Layer）**

- **包含**：Android、iOS、Web、Windows、macOS 客户端  
- **交互方式**：  
  - 直连服务器  
  - 局域网（LAN）转发  
  - 广域网（WAN）隧道穿透  

2. **云服务层（Cloud Layer）**

- 云认证系统（用于穿透服务）  
- 穿透中继服务  
- 官方网站/社区/资源中心  

3. **NAS 系统软件架构（自底向上）**

- **Linux 操作系统**  
- **系统服务层** ：OTA 升级服务；磁盘管理服务；系统配置服务  
- **核心服务层** ：网盘服务；用户模块  
- **应用服务层** ： 相册；音乐；影视库；Docker 容器服务  
- **网关层（Gateway）**  

### 1.1.3 技术选型

1. **网盘**  
   在研究如何实现云存储系统时，我了解到三种主要技术：WebDAV、MinIO 和 OwnCloud。  
   - **MinIO**：更适合大规模分布式存储，但我们的 NAS 系统规模较小，因此不符合需求。  
   - **OwnCloud**：更侧重协作功能，这也与我们的使用场景不匹配。  
   - **WebDAV**：是最佳选择，因为它基于 HTTP 协议、内置身份验证机制，且开发更便捷  

2. **网关**  
   主要有 Nginx 和 Traefik 两种网关。  
   - **Nginx**：是一个高性能的 HTTP 和反向代理服务器，支持负载均衡、缓存、安全等功能。复杂需求比较麻烦，需要使用 Lua 脚本或其他插件  
   - **Traefik**：是一个开源的边缘路由器，支持动态配置、负载均衡、服务发现等功能，中间件机制（Middleware）让你可以在路由链上自由插入鉴权、限流、重试等逻辑  

### 1.1.4 网盘
#### 存文件的方式
#### 比方说现在说一个G的文件传上来 你是字节全部到内存里然后写到文件上去吗
#### 零拷贝
#### 1. 如何存几百 GB 的大文件？分片上传、断点续传
  
   - 若请求包含 `Content-Range` 头部，表示该文件是分块上传的，它会解析 `Content-Range`，获取文件的起始字节与结束字节。  
   - 如果 `tmpFilePath` 文件已经存在且其大小与 `Content-Range` 中提供的开始字节（`startByte`）匹配，它会通过 `resumeUpload` 函数继续接收文件数据。
   - 如果是分块上传，它会在指定的临时文件路径（`tmpFilePath`）下存储文件，并在上传成功后将文件移动到目标路径（`realFilePath`）。  

#### 2. 如何检测文件损坏并使用备份？容灾机制
   - **本地副本**：NAS 设备内部会将文件系统中的数据写入多个硬盘或磁盘阵列中，保障即使硬盘出现故障也能保证数据的高可用性。例如，RAID 5、RAID 6 等技术。  
   - **远程副本**：通过远程的 NAS 存储设备或者云存储服务，将数据实时或定时复制到不同的地点。这样，即使数据中心发生故障，另一个地理位置的副本依然能够提供访问。

#### 3. 减少存储空间占用
   - **数据去重**：通过去重算法减少重复数据的存储  
   - **数据压缩**：使用压缩算法（如 Gzip、Zstandard）减少文件大小  

#### 4. 如何加速下载文件

**协议层：**
   - **HTTP/2 或 HTTP/3**：多路复用减少连接开销，提升小文件并发下载效率

**内容分发层**
   - **CDN 加速**：将文件缓存到全球分布的边缘节点，用户访问时自动选择最近的节点下载
   - **P2P 分发**：BitTorrent 协议

**数据层优化**
   - **压缩传输**：
   - **分块下载**：
      - **`Range`** 请求支持断点续传
      - 多线程分块下载（如 aria2 的 **`x 16`** 参数）

#### 5. 如何判断一个文件是否支持分块下载
   发送带 `Range` 请求头的 HTTP 请求，看是否返回206 partial Content

#### 6. 对于 100G 的大文件，移动操作是否会影响性能？
- 解决方案 ：
   - 文件系统优化 ：现代文件系统（如 ext4、NTFS）对文件移动操作进行了优化，移动操作实际上是修改文件元数据，而不是复制数据，因此性能开销很小。
   - 原子性保证 ：即使文件很大，移动操作也是原子的，确保数据一致性。

### 1.1.5 OTA

#### 1. 终端与服务端的交互流程

1. **检查升级请求**  
   - 终端设备发送请求到服务端，携带当前固件版本号，以检查是否有可升级的 OTA 固件包。  

2. **设备身份验证**  
   - 服务端验证终端的 SN 号是否属于测试设备池或正式设备池。根据设备的身份（测试设备或正式设备），决定固件包的选择。  
   - **测试设备**：服务端会提供状态为“待测试”的固件包。  
   - **正式设备**：服务端提供状态为“已发布”的固件包。  

3. **获取固件包下载链接**  
   - 当设备符合升级条件时，终端发送请求获取固件包下载链接，服务端验证并返回有效的临时下载链接。  

4. **终端下载固件包**  
   - 终端设备通过服务端提供的下载链接执行固件包的下载。  

#### 2. 客户端（终端）流程

1. **电量检查**  
   - 设备首先检查电量，若低于 50%，则终止 OTA 升级流程。  

2. **固件包下载**  
   - **检查 OTA 服务是否空闲**：若服务忙碌，终止流程。  
   - **检查目标文件路径并验证文件的 MD5 值**：确保下载的 OTA 包无误。  
   - **断点续传和错误检测**：确保文件完整性。  

3. **OTA 包校验**  
   - 下载完成后，验证 OTA 包的 MD5 码和完整性，确保其无误。  

4. **OTA 包安装**  
   - **解析 OTA 升级包**：启动 AB 升级流程（安装引擎检查并安装更新）。 
       1. 设备存储划分为两个系统分区（A分区和B分区）
       2. 当前运行的系统在A分区时，更新包安装到B分区
       3. 重启后自动切换到更新后的B分区运行
       4. 若更新失败，自动回退到原A分区 
   - **错误处理**：在安装过程中，若出现错误，升级引擎会回滚至之前版本。

### 1.1.6 并发处理
#### 1. rate限流
   1. sync.map作一个全局的并发安全的存储容器
   2. 每个键值对存储的是 route + "_" + userID 到 *rate.Limiter 的映射。
   3. 每个 *rate.Limiter 都是一个独立的令牌桶
      核心概念：
      - 令牌桶：想象一个桶，里面装着令牌
      - 每个请求需要消耗一个令牌
      - 令牌以固定速率被添加到桶中
      - 当桶中没有令牌时，请求会被限制
   4. 通过 limiter.Allow() 方法来判断是否允许当前请求
#### 2. 缓存
   1. 使用了 ristretto 作为缓存库，这是一个高性能的并发缓存库
   2. 相比于 redis，它的内存占用更小，性能更好，不需要额外的服务配置和管理
#### 3. 锁
   1. 针对一些耗时或不能并发的操作，会上锁

## 2.1 问题
### 2.1.1 最困难的问题

1. 客户端、nas服务端、云端和穿透服务端沟通联系的过程交互
2. ai相册的实现

### 2.1.2 如果中间人攻击抓取Token，系统如何防范？如何确保Token只能由合法客户端使用？

1. 增加额外验证机制

- 二次验证：在关键操作时，除 nas-token 外，还要求用户提供短信验证码、邮件验证码等。
- 动态挑战-响应机制：服务端向客户端发送随机挑战，客户端使用 nas-token 对挑战进行签名，服务端验证签名结果。

2. 监控与审计

- 异常检测：对请求进行实时监控，若发现异常请求模式（如短时间内大量请求、来自异常 IP 的请求等），及时采取封禁措施。
- 审计日志：记录所有请求的详细信息，包括请求头、请求时间、请求 IP 等，便于后续安全审计和问题排查。


 