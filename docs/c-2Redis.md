------

# Redis

> 作者：hou

------

## 1.1 Redis基础

### 1.1.1 基本数据结构

1. **String**  
   - 二进制安全的键极短存储，最大支持 512MB  
   - **底层数据结构**：简单动态字符串（SDS，Simple Dynamic String）  

2. **Hash**  
   - 键极短对集合，适合存储对象  
   - **底层数据结构**：压缩列表（ziplist）或哈希表（hashtable）  

3. **Set**  
   - 无序唯一集合，适合存储不重复的元素  
   - **底层数据结构**：整数集合（intset）或哈希表（hashtable）  

4. **Sorted Set**  
   - 有序唯一集合，适合存储需要排序的元素  
   - **底层数据结构**：压缩列表（ziplist）或跳表（skiplist）  

5. **List**  
   - 有序集合，适合存储列表数据  
   - **底层数据结构**：压缩列表（ziplist）或双向链表（linkedlist）  

6. **HyperLogLog**  
   - 极省空间的近似去重计数，适合统计不重复元素的数量  
   - **底层数据结构**：HyperLogLog 算法  

7. **Stream**  
   - 流，持久化消息队列，适合处理消息流  
   - **底层数据结构**：基数树（Radix Tree）  

### 1.1.2 Redis底层数据结构

1. **SDS（Simple Dynamic String）**  
   - **定义**：SDS 是 Redis 中用于存储字符串的底层数据结构，是对 C 语言原生字符串的封装和优化  
   - **结构**：SDS 由三部分组成：  
     - `len`：记录字符串的当前长度  
     - `free`：记录未使用的字节数  
     - `buf`：存储实际的字符串内容  
   - **优点**：  
     1. 常数时间获取长度  
     2. 拼接避免内存泄漏  
        1. **动态扩容机制**：  
           当字符串需要扩展时，SDS 会预分配额外空间（策略类似 Java ArrayList）：  
           - 若新长度 `< 1MB`，则分配 `2 * len` 的空间（加倍扩容）。  
           - 若新长度 `>= 1MB`，则每次多分配 `1MB`（避免过度浪费）。  
     3. 二进制安全  
        1. SDS 依赖 `len` 字段而非 `\0` 判断字符串结束，因此可以存储任意二进制数据（包括 `\0` 字节）。  
        2. Redis 的键、值均可安全存储图片、ProtoBuf 序列化数据等二进制内容  
     4. **惰性空间释放（优化性能）**  
        1. **机制**：缩短字符串时，SDS 不会立即回收内存，而是通过 `free` 字段记录可用空间，供后续操作复用。  
        2. **优势**：避免频繁内存重分配，提升性能（如 `APPEND` 操作可能直接复用剩余空间）。  
     5. **兼容 C 字符串函数**  
        1. **实现技巧**：SDS 的 `buf` 尾部依然保留 `\0`（但不依赖它），因此可直接复用 `<string.h>` 的部分函数。  

2. **压缩列表（ziplist）**  
   - **定义**：Ziplist 是 Redis 为优化内存效率设计的一种紧凑型线性数据结构，广泛应用于存储小规模的列表（List）、哈希（Hash）和有序集合（ZSet）的底层实现。其核心思想是通过连续内存布局和变长编码减少内存碎片和冗余开销。  
   - **数据结构**：  
     1. **内存布局**：  
        `<zlbytes><zltail><zllen><entry><entry>...<zlend>`  
        - `zlbytes` (4字节)：整个 ziplist 占用的内存总字节数。  
        - `zltail` (4字节)：指向最后一个 Entry 的偏移量（方便反向遍历）。  
        - `zllen` (2字节)：Entry 的数量（若超过 `UINT16_MAX`，需遍历统计）。  
        - `entry`：存储实际数据的单元（变长结构）。  
        - `zlend` (1字节)：固定值 `0xFF`，标记 ziplist 结束。  
     2. **Entry 结构**：  
        `<prevlen><encoding><content>`  
        - `prevlen`：前一个 Entry 的长度（用于反向遍历）。  
          - 若前一个 Entry 长度 `< 254字节`，`prevlen` 占 1字节。  
          - 否则占 5字节（首字节固定 `0xFE`，后4字节存储实际长度）。  
        - `encoding`：标识 `content` 的数据类型和长度（变长编码）。  
          - **字符串**：高2位表示类型（如 `00` 表示长度≤63字节的字符串）。  
          - **整数**：高2位为 `11`，后续位标识整数类型（如 `int16_t`、`int32_t`）。  
        - `content`：实际存储的数据（字符串或整数值）。  
   - **核心优势**：  
     1. **极致的内存效率**：  
        - 连续内存：无指针开销（对比链表每个节点需额外存储 `next`/`prev` 指针）。  
        - 变长编码：根据数据实际大小动态调整存储空间（如小整数用1字节存储）。  
        - 示例：存储 `[1, "foo", 2]` 时，ziplist 可能仅占用 20字节，而普通链表需 50+字节。  
     2. **缓存友好**：数据紧密排列，CPU 缓存命中率高，适合遍历操作。  
     3. **支持多种数据类型**：可混合存储整数和字符串，无需额外转换。  
   - **缺陷与优化**：  
     1. **连锁更新问题**：  
        - **问题场景**：当插入一个较大的 Entry 导致后续多 `prevlen` 从1字节扩展为5字节时，需级联更新后续所有 Entry（最坏时间复杂度 O(n²)）。  
        - **解决方案**：Redis 通过限制 ziplist 的最大长度（`list-max-ziplist-size`）和单个 Entry 大小来规避风险。  
     2. **修改效率低**：  
        - **插入/删除**：需移动后续所有数据（类似数组操作），适合读多写少的场景。  
        - **优化策略**：当数据量超过阈值时，自动转换为双向链表（List）或哈希表（Hash）。

3. **哈希表（hashtable）**  
   - **定义**：Redis 的哈希表实现中维护了两个哈希表（`dictht ht[2]`），这主要是为了支持渐进式 rehash。  
   - **渐进式 Rehash 的需求**：  
     1. **准备阶段**：分配 ht[1] 的空间（大小根据扩容/缩容策略决定）。  
     2. **渐进迁移**：  
        - 在每次增删改查操作时迁移少量键值对。  
        - 有一个 rehashidx 变量记录当前迁移进度。  
     3. **完成阶段**：当所有键值对迁移完成后，释放 ht[0]，将 ht[1] 设置为 ht[0]。  
   - **优势**：  
     1. **避免长时间阻塞**：单线程的 Redis 可以避免因大量数据迁移导致的长时间阻塞。  
     2. **平滑过渡**：服务可以持续处理请求，对客户端几乎无感知。  
     3. **性能可控**：将迁移成本分摊到多个操作中。  
   - **触发 Rehash 的条件**：  
     1. **扩容**：当元素数量与哈希表大小的比值（负载因子）超过 1 时。  
     2. **缩容**：当负载因子低于 0.1 时。  

4. **整数集合（intset）**  
   - **定义**：整数集合是 Redis 中用于存储整数的数据结构，支持高效的插入、删除和查找操作。  
   - **结构**：由多个整数组成，整数之间按升序排列。  
   - **优点**：  
     - **内存高效**：通过紧凑存储减少内存碎片。  
     - **适合小规模整数集合**：适合存储小规模的整数集合。  

5. **跳表（skiplist）**  
   - **定义**：跳表是一种有序数据结构，支持高效的查找、插入和删除操作。  
   - **结构**：由多个层级组成，每个层级包含多个节点，节点之间通过指针连接。  
   - **优点**：  
     - **O(log n) 时间复杂度**：支持高效的查找、插入和删除操作。  
     - **适合有序集合**：适合存储有序集合。  

6. **双向链表（linkedlist）**  
   - **定义**：双向链表是 Redis 中用于存储列表的数据结构，支持高效的插入、删除和查找操作。  
   - **结构**：由多个节点组成，每个节点存储一个元素，节点之间通过指针连接。  
   - **优点**：  
     - **O(1) 时间复杂度**：支持高效的插入和删除操作。  
     - **适合大规模列表**：适合存储大规模的列表。  

7. **HyperLogLog**  
   - **定义**：HyperLogLog 是一种用于统计不重复元素数量的算法。  
   - **结构**：由多个桶组成，每个桶存储一个计数值。  
   - **优点**：  
     - **极省空间**：通过概率算法减少内存占用。  
     - **适合大规模数据统计**：适合统计大规模数据的不重复元素数量。  

8. **基数树（Radix Tree）**  
   - **定义**：基数树是一种用于存储流数据的数据结构，支持高效的插入、删除和查找操作。  
   - **结构**：由多个节点组成，每个节点存储一个字符，节点之间通过指针连接。  
   - **优点**：  
     - **O(k) 时间复杂度**：支持高效的查找、插入和删除操作，k 为键的长度。  
     - **适合流数据**：适合存储和处理流数据

9. **快表**：  
  - 将多个 Ziplist 用双向链表连接起来。  
  - 每个 Ziplist 称为一个节点（Node），存储多个 List 元素。  
  - 通过控制单个 Ziplist 的大小，避免其缺陷。  