------

# Redis

> 作者：hou

## 1.1 Redis基础

### 1.1.1 基本数据结构

1. **String**  
- 二进制安全的键极短存储，最大支持 512MB  
- **底层数据结构**：简单动态字符串（SDS，Simple Dynamic String）  

2. **Hash**  
- 键值对集合，适合存储对象  
- **底层数据结构**：压缩列表（ziplist）或哈希表（hashtable）  

3. **Set**  
- 无序唯一集合，适合存储不重复的元素  
- **底层数据结构**：整数集合（intset）或哈希表（hashtable）  

4. **Sorted Set**  
- 有序唯一集合，适合存储需要排序的元素  
- **底层数据结构**：压缩列表（ziplist）或跳表（skiplist）  

5. **List**  
- 有序集合，适合存储列表数据  
- **底层数据结构**：压缩列表（ziplist）或双向链表（linkedlist）  

6. **HyperLogLog**  
- 极省空间的近似去重计数，适合统计不重复元素的数量  
- **底层数据结构**：HyperLogLog 算法  

7. **Stream**  
- 流，持久化消息队列，适合处理消息流  
- **底层数据结构**：基数树（Radix Tree）  

### 1.1.2 Redis底层数据结构

1. **SDS（Simple Dynamic String）**  
- **定义**：SDS 是 Redis 中用于存储字符串的底层数据结构，是对 C 语言原生字符串的封装和优化  
- **结构**：SDS 由三部分组成：  
  - `len`：记录字符串的当前长度  
  - `free`：记录未使用的字节数  
  - `buf`：存储实际的字符串内容  
- **优点**：  
  - **O(1) 时间复杂度获取字符串长度**：通过 `len` 字段直接获取长度，无需遍历  
  - **二进制安全**：可以存储任意二进制数据，不会因为遇到 `\0` 而截断  
 极短 - **减少内存重分配**：通过预分配和惰性释放策略，减少内存重分配次数  
  - **兼容 C 字符串**：极短SDS 的 `buf` 字段以 `\0` 结尾，可以直接使用 C 语言的字符串函数  

2. **压缩列表（ziplist）**  
- **定义**：压缩列表是一种紧凑的、连续内存存储的数据结构，用于存储小规模的列表或哈希  
- **结构**：由多个节点组成，每个节点存储一个元素，节点之间通过指针连接  
- **优点**：  
  - **内存高效**：通过紧凑存储减少内存碎片  
  - **适合小数据**：适合存储小规模的列表或哈希  

3. **哈希表（hashtable）**  
- **定义**：哈希表是 Redis 中用于存储键值对的数据结构，支持高效的查找、插入和删除操作  
- **结构**：由多个哈希桶组成，每个哈希桶存储一个键值对  
- **优点**：  
  - **O(1) 时间复杂度**：支持高效的查找、插入和删除操作  
  - **动态扩容**：当哈希表负载因子过高时，会自动进行扩容  

4. **整数集合（intset）**  
- **定义**：整数集合是 Redis 中用于存储整数的数据结构，支持高效的插入、删除和查找操作  
- **结构**：由多个整数组成，整数之间按升序排列  
- **优点**：  
  - **内存高效**：通过紧凑存储减少内存碎片  
  - **适合小规模整数集合**：适合存储小规模的整数集合  

5. **跳表（skipl极短ist）**  
- **定义**：跳表是一种有序数据结构，支持高效的查找、插入和删除操作  
- **结构**：由多个层级组成，每个层级包含多个节点，节点之间通过指针连接  
- **优点**：  
  - **O(log n) 时间复杂度**：支持高效的查找、插入和删除操作  
  - **适合有序集合**：适合存储有序集合  

6. **双向链表（linkedlist）**  
- **定义**：双向链表是 Redis 中用于存储列表的数据结构，支持高效的插入、删除和查找操作  
- **结构**：由多个节点组成，每个节点存储一个元素，节点之间通过指针连接  
- **优点**：  
  - **O(1) 时间复杂度**：支持高效的插入和删除操作  
  - **适合大规模列表**：适合存储大规模的列表  

7. **HyperLogLog**  
- **定义**：HyperLogLog 是一种用于统计不重复元素数量的算法  
- **结构**：由多个桶组成，每个桶存储一个计数值  
- **优点**：  
  - **极省空间**：通过概率算法减少内存占用  
  - **适合大规模数据统计**：适合统计大规模数据的不重复元素数量  

8. **基数树（Radix Tree）**  
- **定义**：基数树是一种用于存储流数据的数据结构，支持高效的插入、删除和查找操作  
- **结构**：由多个节点组成，每个节点存储一个字符，节点之间通过指针连接  
- **优点**：  
  - **O(k) 时间复杂度**：支持高效的查找、插入和删除操作，k 为键的长度  
  - **适合流数据**：适合存储和处理流数据

### 1.1.3 单进程单线程的？

Redis 是单进程单线程的，redis 利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。

## 1.2 Redis性能优化

### 1.2.1 性能优化策略

1. **使用批量操作**  
- 通过批量操作减少网络开销  

2. **大量 key 过期**  
- 采取定期删除 + 懒汉式删除策略  

3. **Bigkey**  
- 一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey  
  - **分割**：将 bigkey 分割成多个小 key  
  - **清理**：定期清理不再使用的 bigkey  
  - **采用合适的数据结构**：选择合适的数据结构存储数据  
  - **开启 lazy-free**：异步释放内存，避免阻塞主线程  

4. **Hotkey**  
- 一个 key 的访问次数比较多且明显多于其他 key 的话  
  - **读写分离**：主节点处理写请求，从节点处理读请求  
  - **使用 Redis Cluster**：将热点数据分散存储在多个 Redis 节点上  
  - **二级缓存**：hotkey 采用二级缓存的方式进行处理，将 hotkey 存放一份到 JVM 本地内存中（可以用 Caffeine）  

## 1.3 Redis缓存问题

### 1.3.1 缓存穿透

1. **问题描述**  
- 大量请求的 key 是不合理的，**根本不存在于缓存中，也不存在于数据库中**  

2. **解决方案**  
- **缓存无效 key**：将无效的 key 缓存起来，避免重复查询数据库  
- **布隆过滤器**：使用布隆过滤器过滤无效的 key  
- **接口限流**：对接口进行限流，避免大量请求直接打到数据库  

### 1.3.2 缓存击穿

1. **问题描述**  
- **热点数据**，该数据 **存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）**  

2. **解决方案**  
- **永不过期**：设置热点数据永不过期  
- **提前预热**：在缓存失效前提前预热数据  
- **加锁**：使用分布式锁避免多个请求同时查询数据库  

### 1.3.3 缓存雪崩

1. **问题描述**  
- **缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力**  

2. **解决方案**  
- **针对 Redis 服务不可用的情况**：使用 Redis 集群，多级缓存  
- **针对大量缓存同时失效的情况**：**设置随机失效时间、提前预热**  

## 1.4 Redis持久化机制

### 1.4.1 持久化机制

1. **RDB**  
- 快照式的持久化机制。定期将内存中的数据集保存到磁盘上的一个 RDB 文件中  

2. **AOF**  
- 日志式的持久化机制。将每个写操作（如 `SET`、`LPUSH` 等）追加到一个日志文件（通常是 `appendonly.aof`）
