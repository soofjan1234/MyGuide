------

# Go内存

> 作者：hou
------
# 内存回收
自动化内存管理机制，用于回收程序中不再使用的内存资源

采取的是“非分代的、非移动的、并发的、三色的”标记清除垃圾回收算法

原理：
- 首先把所有的对象都放到白色的集合中
- 从根节点开始遍历对象，遍历到的白色对象从白色集合中放到灰色集合中
- 遍历灰色集合中的对象，把灰色对象引用的白色集合的对象放入到灰色集合中，同时把遍历过的灰色集合中的对象放到黑色的集合中
- 循环步骤3，知道灰色集合中没有对象
- 步骤4 结束后，白色集合中的对象就是不可达对象，也就是垃圾，进行回收

# 内存泄露

内存泄漏（Memory Leak）是指在程序运行过程中，已经分配的内存没有被正确释放，导致程序使用的内存不断增加，最终可能导致系统资源枯竭、程序性能下降甚至崩溃。

1. 未释放的内存：程序申请了内存，但没有在合适的时机释放，导致内存一直占用，直到程序退出。

2. 未关闭的资源：例如，打开的文件、数据库连接或网络连接等没有被关闭，导致这些资源一直占用内存。

3. 循环引用：特别是在使用垃圾回收机制的语言中，如果两个对象相互引用，且没有其他地方引用它们，即使它们不再需要，也可能无法被垃圾回收器回收，导致内存泄漏

# 内存逃逸
当一个变量的生命周期超出了栈的范围，导致它被分配到堆上，而不是栈上。
栈内存是由编译器自动管理的，而堆内存则由垃圾回收器（GC）管理，通常堆上的变量生命周期更长，但也会带来更多的内存管理开销

典型情况：

- **在方法内把局部变量指针返回**  
 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。 

- **发送指针或带有指针的值到 channel 中**  
 在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。

- **在一个切片上存储指针或带指针的值**  
 一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。

- **slice 的背后数组被重新分配**  
因为 append 时可能会超出其容量( cap )。 slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。

- **在 interface 类型上调用方法**  
在 interface 类型上调用方法都是动态调度的。方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片 b 的背后存储都逃逸掉，所以会在堆上分配。

## 为什么要关注内存逃逸
1. 优化内存使用：
    - 栈由编译器自动管理，分配和释放速度非常快
    - 堆内存由垃圾回收器管理，过程复杂，管理开销大
2. 减少内存泄漏风险：更好了解程序内存使用情况
3. 性能优化：某些性能要求高的场景中，内存逃逸可能成为性能瓶颈