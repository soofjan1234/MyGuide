------

# Go基础

> 作者：hou
------
## 1.1 Go
### 1.1.1 Go语言的优点

1. **天然支持高并发**  
Go语言通过goroutine和channel机制，提供了轻量级的并发支持。goroutine的创建和调度开销远小于线程，使得Go在处理高并发场景时表现出色。

2. **学习成本低，上手快**  
Go语言的语法简洁，去除了许多复杂的概念（如继承、泛型等），使得开发者可以快速上手并投入生产。

3. **性能高**  
Go语言编译后的二进制文件直接运行在操作系统上，无需虚拟机，执行效率高。同时，Go的垃圾回收机制经过优化，减少了GC带来的性能损耗。

4. **编译后二进制包体积小**  
Go语言编译后的二进制文件不依赖外部库，体积小，便于部署和分发。

### 1.1.2 Go和Java的区别

1. **语言性**: Go简单；Java语言较为复杂，包含更多特性  

2. **类型系统**：
    - Go支持类型推断，
    - Go不支持继承，使用组合来实现代码复用，更加灵活，松耦合；Java支持继承和多态  

3. **并发**：Go使用goroutines和channels实现并发；Java基于Thread和Runnable实现并发  

4. **跨平台**：Go直接编译为机器码，性能高；Java需要JVM运行，性能相对较低  

5. **垃圾回收** ：Go支持并发垃圾回收，使用并行标记-清除算法；Java使用多种垃圾回收器，如G1、CMS等  

### 1.1.3 Gin和SpringBoot区别

1. **性能**  
- Gin能够处理大量并发请求  
- 由于Java的线程模型和JVM启动时间，SpringBoot通常不如Gin  

2. **开发体验**  
- Gin提供了中间件支持，可以方便地扩展功能  
- SpringBoot通过注解和约定优于配置的方式简化开发

## 1.2 Go切片
### 1.2.1 切片和数组的区别？

1. **长度**：数组长度固定；长度可变，支持自动扩容

2. **声明方式不同** ：数组`var arr [5]int`；切片`var slice []int`

3. **内存分配** ：数组值类型；切片引用类型，底层引用数组  

4. **传递开销**：数组传递时会复制整个数组；切片仅复制切片头（包含指针、长度和容量）

### 1.2.2 切片的关键特性、基本属性、注意点

1. **底层依赖数组**  
当切片基于数组创建时，它们会**共享同一块底层内存空间**。这意味着通过切片修改元素会直接影响原始数组，反之亦然。  

2. **创建方式**  
- 从数组创建：`slice := arr[start:end]`  
- 直接创建：`slice := make([]int, length, capacity)`  

3. **零值**  
切片的零值为`nil`，表示未初始化的切片。  

4. **性能优化**  
- 一次分配足够空间，避免频繁扩容  
- 合理设置容量，减少内存分配次数  

### 1.2.3 如何扩容

1. **触发条件**  
当切片的长度超过容量时，Go会自动触发扩容。  

2. **扩容算法**  
- 小切片(<256元素)：双倍扩容  
- 大切片(≥256元素)：平滑过渡到约1.25倍扩容  

3. **内存对齐、分片**  
Go在扩容时会考虑内存对齐，以提高访问效率。  

4. **数据迁移**  
扩容后，原数据会被复制到新的内存空间。  

## 1.3 Go的map
### 1.3.1 底层实现
基于 哈希表（Hash Table）+ 多级桶（bucket）+ 链表或溢出桶机制 实现的

1. **hmap结构体**  
   - 包含buckets指针、哈希种子hash0、B值（2^B=桶数量）等元信息
   - 记录元素数量、oldbuckets、扩容状态等
2. **bmap（桶结构）**  
   - 每个桶存储8个键值对
   - 包含：
     - tophash数组（存储键哈希的高8位）
     - keys数组（连续存储）
     - values数组（连续存储）
     - overflow指针（指向溢出桶）

### 1.3.2 如何扩容
#### 1. 触发条件
- 装载因子 > 6.5（平均每个桶6.5个元素）
- 删除大量key导致空间浪费
- 需要频繁创建overflow bucket

#### 2. 扩容过程
1. **渐进式迁移**  
   - 不一次性复制所有数据
   - 在每次插入/查找时迁移部分数据

2. **扩容类型**  
   - 增量扩容（扩大桶数量）
   - 等量扩容（整理溢出桶）

### 1.3.3 go中的Map 并发安全吗
1. **竞态条件（Race Condition）**  
多个goroutine同时读写map时，可能会引发竞态条件，导致程序崩溃或数据错误。
2. **内部实现**  
Go的map是基于哈希表实现的，多个goroutine同时修改哈希表的结构（如扩容）会导致不可预测的行为。

- 实现并发安全，可以用sync.mutex，sync.map或分段锁

### 1.3.4 查找、插入、删除的操作流程

#### 1. 查找流程
1. 计算key的哈希值
2. 定位到对应bucket
3. 比较tophash和完整key

#### 2. 插入流程
1. 查找是否存在相同key
2. 找到空槽位或创建溢出桶
3. 必要时触发扩容

#### 3. 删除流程
1. 定位到对应bucket
2. 清空key/value数据
3. 延迟回收溢出桶空间

## 1.4 Go其他
### 1.4.1 深度拷贝

1. **使用json序列化、反序列化**  
通过json序列化和反序列化实现深度拷贝，但性能较低。  

2. **gob编码**  
使用gob编码进行深度拷贝，比json性能更好，可以处理更复杂的类型。  

3. **第三方库**  
可以使用`github.com/jinzhu/copier`等第三方库实现深度拷贝。  

4. **手动实现**  
对于简单的结构体，可以手动实现深度拷贝方法。 

### 1.4.2 锁

1. 互斥锁mutex
2. 读写锁rwmutex
3. 原子操作
4. sync.map
5. waitGroup
   WaitGroup 提供了三个基本操作：
    Add：设置要等待的 goroutine 数量。
    Done：通知 WaitGroup 一个任务已经完成。
    Wait：阻塞直到所有的 goroutine 完成
6. channel

### 1.4.3 for-range

#### 1. 基本特性
- Go中所有赋值操作都是值拷贝
- for-range是语法糖，会被编译器转换为传统for循环

#### 2. 切片遍历
1. **添加元素的影响**
   - 不会无限循环：range循环次数在开始时确定(len_temp)
   - 新增元素不会被当前循环遍历到

#### 3. Map遍历
1. **删除元素**
Go官方文档明确指出：
> Don't modify a map while iterating over it. The behavior is not defined and can change from one version of Go to another.

##### 3.2 删除元素
1. **安全性**  
   - 允许删除当前迭代到的元素  
   - 官方说明：`It is safe to delete from a map during iteration`

2. **实现机制**  
   - 遍历开始时构建"内部遍历结构"（非实时快照）  
   - 基于哈希桶的动态读取  
   - 删除可能影响：  
     - 清空键值（桶保留）  
     - 改变桶链结构（特别是overflow bucket）  

3. **可能结果**  
   - 可能遍历到被删除键  
   - 也可能遍历不到（因桶结构变化）  
   - Go不保证一致性  

##### 3.3 添加元素  
Go 官方文档怎么说？
> It is safe to delete from a map during iteration. However, if you add new keys to the map during iteration, the behavior is undefined.
1. **危险性**  
   - 官方警告：`behavior is undefined`  
   - 可能导致：  
     - panic  
     - 漏遍历元素  
     - 重复遍历  
     - 新增键不被遍历  

2. **底层原因**  
   - 可能触发rehash改变桶布局  
   - 遍历使用旧的bucket排列顺序  
   - 指针状态错乱风险：  
     - 读取非法地址  
     - 访问nil值  

### 1.4.4 闭包
闭包 = 一个函数 + 它引用的外部变量的环境

1. 特性：
    - 函数可以访问并且共享外部变量
    - 即使在函数外，变量也不会被 GC
2. 用途：
    - 封装状态
    - 延迟执行
    - 根据不同参数生成不同功能的函数
3. 是否并发安全：
    - 如果是共享变量，需要考虑并发安全
4. 和函数的区别：
    - 普通函数能访问参数+全局变量；闭包还能访问捕获的外部变量
    - 普通函数执行完后，参数和局部变量会被释放；闭包的外部变量会一直存在
    - 闭包内存占用更大些
    