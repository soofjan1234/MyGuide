------

# Go基础

> 作者：hou
------
## 1.1 Go
### 1.1.1 Go语言的优点

1. **天然支持高并发**  
Go语言通过goroutine和channel机制，提供了轻量级的并发支持。goroutine的创建和调度开销远小于线程，使得Go在处理高并发场景时表现出色。

2. **学习成本低，上手快**  
Go语言的语法简洁，去除了许多复杂的概念（如继承、泛型等），使得开发者可以快速上手并投入生产。

3. **性能高**  
Go语言编译后的二进制文件直接运行在操作系统上，无需虚拟机，执行效率高。同时，Go的垃圾回收机制经过优化，减少了GC带来的性能损耗。

4. **编译后二进制包体积小**  
Go语言编译后的二进制文件不依赖外部库，体积小，便于部署和分发。

### 1.1.2 Go和Java的区别

1. **语言性**: Go简单；Java语言较为复杂，包含更多特性  

2. **类型系统**：
    - Go支持类型推断，
    - Go不支持继承，使用组合来实现代码复用，更加灵活，松耦合；Java支持继承和多态  

3. **并发**：Go使用goroutines和channels实现并发；Java基于Thread和Runnable实现并发  

4. **跨平台**：Go直接编译为机器码，性能高；Java需要JVM运行，性能相对较低  

5. **垃圾回收** ：Go支持并发垃圾回收，使用并行标记-清除算法；Java使用多种垃圾回收器，如G1、CMS等  

### 1.1.3 Gin和SpringBoot区别

1. **性能**  
- Gin能够处理大量并发请求  
- 由于Java的线程模型和JVM启动时间，SpringBoot通常不如Gin  

2. **开发体验**  
- Gin提供了中间件支持，可以方便地扩展功能  
- SpringBoot通过注解和约定优于配置的方式简化开发

## 1.2 Go切片
### 1.2.1 切片和数组的区别？

1. **长度**：数组长度固定；长度可变，支持自动扩容

2. **声明方式不同** ：数组`var arr [5]int`；切片`var slice []int`

3. **内存分配** ：数组值类型；切片引用类型，底层引用数组  

4. **传递开销**：数组传递时会复制整个数组；切片仅复制切片头（包含指针、长度和容量）

### 1.2.2 切片的关键特性、基本属性、注意点

1. **底层依赖数组**  
当切片基于数组创建时，它们会**共享同一块底层内存空间**。这意味着通过切片修改元素会直接影响原始数组，反之亦然。  

2. **创建方式**  
- 从数组创建：`slice := arr[start:end]`  
- 直接创建：`slice := make([]int, length, capacity)`  

3. **零值**  
切片的零值为`nil`，表示未初始化的切片。  

4. **性能优化**  
- 一次分配足够空间，避免频繁扩容  
- 合理设置容量，减少内存分配次数  

### 1.2.3 如何扩容

1. **触发条件**  
当切片的长度超过容量时，Go会自动触发扩容。  

2. **扩容算法**  
- 小切片(<256元素)：双倍扩容  
- 大切片(≥256元素)：平滑过渡到约1.25倍扩容  

3. **内存对齐、分片**  
Go在扩容时会考虑内存对齐，以提高访问效率。  

4. **数据迁移**  
扩容后，原数据会被复制到新的内存空间。  

## 1.3 Go的map
### 1.3.1 go中的Map 并发安全吗

1. **竞态条件（Race Condition）**  
多个goroutine同时读写map时，可能会引发竞态条件，导致程序崩溃或数据错误。
2. **内部实现**  
Go的map是基于哈希表实现的，多个goroutine同时修改哈希表的结构（如扩容）会导致不可预测的行为。

- 实现并发安全，可以用sync.mutex，sync.map或分段锁

### 1.3.2 删除map后空间会立即释放吗

不会 ，引用被清除，内存保留  
在触发垃圾回收；map扩容或缩容

## 1.4 Go其他
### 1.4.1 深度拷贝

1. **使用json序列化、反序列化**  
通过json序列化和反序列化实现深度拷贝，但性能较低。  

2. **gob编码**  
使用gob编码进行深度拷贝，比json性能更好，可以处理更复杂的类型。  

3. **第三方库**  
可以使用`github.com/jinzhu/copier`等第三方库实现深度拷贝。  

4. **手动实现**  
对于简单的结构体，可以手动实现深度拷贝方法。 

### 1.4.2 锁

1. 互斥锁mutex
2. 读写锁rwmutex
3. 原子操作
4. sync.map
5. waitGroup
   WaitGroup 提供了三个基本操作：
    Add：设置要等待的 goroutine 数量。
    Done：通知 WaitGroup 一个任务已经完成。
    Wait：阻塞直到所有的 goroutine 完成
6. channel

