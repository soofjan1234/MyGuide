------

# NSQ

> 作者：hou

## 1.1 NSQ 是什么

NSQ 是一个实时分布式消息传递平台，设计用于处理大规模的消息流。它由 Bitly 开发，具有高可用性、高吞吐量和低延迟的特点。

## 1.2 NSQ 核心概念

1. **Topic**  
- 消息的主题，生产者将消息发送到特定的 Topic  

2. **Channel**  
- 消费者通过订阅特定的 Channel 来消费消息，一个 Topic 可以有多个 Channel  

3. **Message**  
- 消息的基本单元，包含消息体和元数据  

4. **Producer**  
- 生产者，负责将消息发送到 NSQ 集群  

5. **Consumer**  
- 消费者，负责从 NSQ 集群中消费消息  

## 1.3 NSQ 架构

### 1.3.1 nsqd
- NSQ 的核心组件，负责接收、存储和传递消息  

**特性**:
1. **负载均衡策略**  
   - 对订阅了同一个 Topic，同一个 Channel 的消费者使用负载均衡策略（不是轮询）  

2. **消息缓存**  
   - 只要 Channel 存在，即使没有该 Channel 的消费者，也会将生产者的 Message 缓存到队列中（注意消息的过期处理）  

3. **消息持久化**  
   - 保证队列中的 Message 至少会被消费一次，即使 nsqd 退出，也会将队列中的消息暂存磁盘上（结束进程等意外情况除外）  

4. **内存管理**  
   - 限定内存占用，能够配置 nsqd 中每个 Channel 队列在内存中缓存的 Message 数量，一旦超出，Message 将被缓存到磁盘中  

5. **资源管理**  
   - Topic 和 Channel 一旦建立，将会一直存在，要及时在管理台或者用代码清除无效的 Topic 和 Channel，避免资源的浪费  

### 1.3.2 nsqlookupd
- 负责管理 nsqd 的注册和发现，消费者通过 nsqlookupd 找到可用的 nsqd  

**特性**:
1. **唯一性**  
   - 在一个 NSQ 服务中只有一个 nsqlookupd 服务。当然也可以在集群中部署多个 nsqlookupd，但它们之间是没有关联的  

2. **去中心化**  
   - 即使 nsqlookupd 崩溃，也不会影响正在运行的 nsqd 服务  

3. **信息交互中间件**  
   - 充当 nsqd 和 nsqadmin 信息交互的中间件  

4. **HTTP 查询服务**  
   - 提供一个 HTTP 查询服务，给客户端定时更新 nsqd 的地址目录  

### 1.3.3 nsqadmin
- 提供 Web 界面，用于监控和管理 NSQ 集群  

## 1.4 NSQ 与其他消息队列的对比

| 维度                 | NSQ                                                        | Kafka                                                      | RabbitMQ                                                                 |
| -------------------- | ---------------------------------------------------------- | ---------------------------------------------------------- | ------------------------------------------------------------------------ |
| **架构模型**           | 去中心化：`nsqlookupd` + 多个 `nsqd` + `nsqadmin`；无单点协调器 | 分布式日志：Broker 集群 + ZooKeeper/KRaft（Coordinator）     | 中心化：Broker 集群 + 可选 HA 管理节点（Classic/Mirrored Queues 或 Quorum Queues） |
| **消息存储 & 持久化**   | 内存优先，异步刷盘到本地文件；单副本，无跨节点复制               | 严格追加日志写盘，可配置副本因子；多副本同步复制               | 内存+磁盘；镜像队列（Mirrored Queues）或 Quorum Queues 提供多副本高可用            |
| **消费语义**           | 默认至少一次；无事务；顺序仅限同 channel 单消费者             | 至少一次；开启事务可 exactly-once；分区内严格顺序保证           | 至少一次；支持事务与确认（ack/nack）；单队列内可保证顺序                              |
| **路由 & 排序**        | Topic→Channel→Consumer；Channel 负载均衡或多路广播            | Topic→Partition；基于 Key Hash 路由；分区内严格顺序             | Exchange（Direct/Fanout/Topic/Headers）灵活路由，队列内有序                           |
| **可扩展性**           | 增加 `nsqd` & `nsqlookupd` 实例即可水平扩展                  | 扩增 Broker 与 Partition；强一致性 Rebalance                | 集群扩展需镜像队列，水平扩容不如 Kafka 自然                                       |
| **吞吐 & 延迟**        | 数万条/s，<1 ms 延迟                                        | 数十万条/s，延迟可调至 ms 级                                 | 中等吞吐（数万条/s），消息确认与路由延迟略高                                       |
| **运维复杂度**         | 轻量：3 个组件，配置简单                                     | 较高：Broker、ZooKeeper/KRaft、Rebalance、Schema Registry、Connectors… | 中等：Broker 集群 + 管理插件（Shovel、Federation、Management UI）             |

## 1.5 NSQ 消息不丢失保证

1. **消息持久化**  
   - 消息被持久化到磁盘，确保在 nsqd 重启后消息不丢失  

2. **消息确认机制**  
   - 消费者在成功处理消息后发送确认信号（ACK），确保消息被正确处理  
   - 如果消费者未发送 ACK，消息会被重新放入队列，等待重新消费  

3. **消息重试机制**  
   - 如果消息处理失败，消费者可以发送重新排队请求（Requeue），消息会被重新放入队列，等待再次处理  

4. **消息超时处理**  
   - 如果消息在指定时间内未被处理，nsqd 会自动将其重新放入队列，避免消息因消费者挂起而丢失  

## 1.6 NSQ 避免重复消费

1. **消息去重**  
   - 在消费者端维护一个已消费消息的缓存，通过消息的唯一标识进行去重  

2. **幂等校验**  
   - 消费消息服务做幂等校验，比如 Redis 的 `set`、MySQL 的主键等天然的幂等功能  

