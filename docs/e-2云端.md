------

# 云端

> 作者：hou

## 1.1  邀请码机制vs传统用户账号系统

### 1.1.1. 邀请码机制

工作原理：
- **生成邀请码**：当NAS设备需要进行穿透时，管理员请求云平台上生成一个唯一的邀请码。
- **邀请码分发**：管理员将邀请码发送给该用户。用户使用邀请码作为凭证进行登录。
- **使用邀请码**：用户输入邀请码，系统验证其合法性后允许访问NAS设备。

优点：
- **简便性**：只需通过云平台生成邀请码，并将其发给用户，无需复杂的注册和账号管理过程。
- **安全性**：邀请码通常具有时效性和唯一性，过期或被篡改的邀请将无法使用。

缺点：
- **易泄露风险**：如果邀请码被不当传输或公开，可能导致未授权用户获取访问权限。

### 1.1.2. 传统用户账号系统

工作原理：
- **用户注册**：用户需要在云平台上注册一个账号，并提供必要的个人信息，如姓名、邮箱等。
- **在线离线**：用户可以在线化、离线化云端账号，以实现灵活的访问控制。
- **登录验证**：用户通过输入账号和密码进行登录验证，系统验证用户的身份和状态。

优点：
- **长期有效性**：云端用户系统适用于长期和持续的访问控制，适合企业级或需要持续管理的环境。
- **安全性高**：支持多重身份验证、访问日志记录、权限审计等，能够提供更高的安全保障。

缺点：
- **注册流程较复杂**：用户需要创建账户、进行身份验证、记住密码等，可能不如邀请码机制简便。
- **管理成本高**：流程复杂，需考虑在线化、离线化、云端宕机等情况

### 1.1.3. 总结

综上所述，根据简单性和便捷性，选择了邀请码机制

## 1.2  穿透交互架构

1. **客户端请求穿透**  
   - 服务端验证管理员身份，向云端请求 `peerID`、`peerPwd`、`accessID` 和 `accessVerify`
      - peerID和peerPwd用于服务端开启穿透
      - accessID用于客户端向云端获取穿透信息
      - accessVerify用于客户端与服务端握手连接  

2. **服务端开启穿透**  
   - 服务端根据 `peer` 账号密码向穿透端开启穿透，配置隧道参数并启动隧道。  

3. **客户端获取信息**  
   - 客户端通过服务端得到 `accessID`，向云端请求得到 `peerID`、`accessVerify`  

4. **客户端开启穿透**  
   - 客户端根据 `peer` 账号向穿透端开启穿透  

5. **握手连接**  
   - 客户端与服务端进行握手连接，校验 `accessVerify`  

## 1.3  AES+RSA 混合加密

### 1.3.1. 对称加密

使用相同的密钥进行加密和解密，常见的算法包括 AES和 DES。

优点：
- 速度快，计算效率高

缺点：
- 密钥管理困难：所有通信方必须共享同一密钥。密钥的传输和管理非常重要，因为如果密钥被泄露，整个系统的安全性就会受到威胁。

### 1.3.2. 非对称加密

使用一对密钥（公钥和私钥）进行加密和解密，常见的算法包括 RSA和 ECC。

优点：
- 密钥交换安全：公钥可以公开，私钥始终保密。即使攻击者获取了公钥，也无法解密数据。
- 适用于身份验证：可以用私钥加密信息，接收方用公钥解密，从而验证消息的发送者身份。
- 无需密钥共享：避免了对称加密中密钥传输的安全风险。

缺点：
- 速度较慢，计算复杂度高：由于RSA等非对称加密的数学复杂性，性能较差。

### 1.3.3 哈希算法

哈希算法用于生成数据的唯一固定长度“指纹”，通常用于数据完整性验证。常见算法有 SHA-256。

优点：
- 速度快：哈希算法处理速度非常快，适合大量数据的验证。
- 不可逆：哈希值无法逆向推导回原始数据，有助于保护数据隐私。
- 防篡改：通过对数据生成哈希值，能够确保数据在传输过程中未被篡改。

缺点：
- 无法解密数据：哈希算法不能加密或解密数据，只能用于验证数据完整性，不能用于保密通信。

### 1.3.4 数字签名

数字签名结合了非对称加密和哈希算法，通常用于验证数据的来源和完整性。

优点：
- 身份验证：数字签名可以验证消息的来源，确保数据确实来自预期的发送者。
- 数据完整性：数字签名可以确保数据在传输过程中没有被篡改。
- 合法性：在法律上，数字签名具有一定的合法效力，广泛应用于合同签署和电子支付等场景。

缺点：
- 性能较差：数字签名涉及哈希和非对称加密的计算，速度比直接的对称加密慢。
- 只验证数据完整性和身份：它不提供加密，无法保护数据的机密性。

### 1.3.5 混合加密

混合加密结合了对称加密和非对称加密的优点，通常用于保护数据的机密性和完整性。

优点：
1. 加密速度和效率：
- AES 是对称加密算法，加密速度快。因此，使用AES来加密实际的数据部分很高效。
- RSA 是非对称加密算法，虽然加密数据时较慢，但非常适合交换加密用的对称密钥（如AES密钥）。RSA仅用于加密和传输小的密钥，而不是整个数据。

2. 密钥交换的安全性：
- 使用 RSA 交换 AES 的密钥。因为非对称加密提供了安全的密钥交换机制，确保AES密钥可以安全地传输，即使是在不安全的网络环境中。
- 通过 RSA 加密 AES 密钥，只有拥有私钥的一方才能解密密钥，从而确保通信安全。

### 1.3.6 加密步骤

1. **生成密钥**：客户端生成 AES 的 `key` 和 `nonce`  

2. **加密数据**：客户端用 AES 加密 `data`  

3. **加密密钥**：客户端用 RSA 公钥加密 AES 的 `key`  

4. **解密密钥**：服务端拿 RSA 私钥解密 `key`  

5. **还原数据**：然后还原 `data`  

## 1.4 NSQ 消息队列

### 1.4.1 NSQ 与 Kafka、RabbitMQ 对比

| 特性                | NSQ                                   | Kafka                                | RabbitMQ                            |
|---------------------|---------------------------------------|--------------------------------------|-------------------------------------|
| **架构模型**         | 去中心化：`nsqlookupd` + 多个 `nsqd`  | 分布式日志：Broker 集群 + ZooKeeper  | 中心化：Broker 集群 + 可选 HA 管理节点 |
| **消息存储 & 持久化** | 内存优先，异步刷盘到本地文件；单副本   | 严格追加日志写盘，可配置副本因子     | 内存+磁盘；镜像队列或 Quorum Queues  |
| **消费语义**         | 默认至少一次；无事务；顺序仅限同 channel 单消费者 | 至少一次；开启事务可 exactly-once；分区内严格顺序保证 | 至少一次；支持事务与确认（ack/nack）；单队列内可保证顺序 |
| **路由 & 排序**      | Topic→Channel→Consumer；Channel 负载均衡或多路广播 | Topic→Partition；基于 Key Hash 路由；分区内严格顺序 | Exchange（Direct/Fanout/Topic/Headers）灵活路由，队列内有序 |
| **可扩展性**         | 增加 `nsqd` & `nsqlookupd` 实例即可水平扩展 | 扩增 Broker 与 Partition；强一致性 Rebalance | 集群扩展需镜像队列，水平扩容不如 Kafka 自然 |
| **吞吐 & 延迟**      | 数万条/s，<1 ms 延迟                  | 数十万条/s，延迟可调至 ms 级         | 中等吞吐（数万条/s），消息确认与路由延迟略高 |
| **运维复杂度**       | 轻量：3 个组件，配置简单              | 较高：Broker、ZooKeeper、Rebalance、Schema Registry、Connectors… | 中等：Broker 集群 + 管理插件（Shovel、Federation、Management UI） |

### 1.4.2 适用场景

1. **NSQ**  
   - 适合实时消息传递、低延迟、高吞吐的场景，如日志收集、事件驱动架构等。  
   - 适合需要简单部署和管理的场景。  

2. **Kafka**  
   - 适合大规模数据流处理、日志聚合、事件溯源等场景。  
   - 适合需要严格顺序保证和高吞吐的场景。  

3. **RabbitMQ**  
   - 适合需要复杂路由、消息确认和事务支持的场景，如任务队列、RPC 调用等。  
   - 适合需要高可用性和灵活性的场景。  

### 1.4.3 总结

- **NSQ**：简单易用，适合实时消息传递和低延迟场景。  
- **Kafka**：适合大规模数据流处理和严格顺序保证的场景。  
- **RabbitMQ**：适合复杂路由和消息确认的场景。

## 2.1 代码
### 2.1.1. lincaccessbackend
主要负责实现远程访问和隧道连接功能

1. 核心功能
远程访问：通过 P2P 隧道技术实现设备的远程访问，允许用户从外部网络访问本地设备。
隧道管理：负责隧道的创建、连接、断开等操作，确保数据传输的安全性和稳定性。
网络状态监控：监听设备的网络状态变化，自动调整隧道连接策略。
后台服务：通过 HostService 实现后台运行，确保隧道连接的持续性和可靠性。

2. 主要类与文件
HostService.kt：后台服务类，负责隧道连接的启动、停止和状态管理。
KtorHost.kt：基于 Ktor 框架的网络服务，处理隧道连接的 HTTP 请求和响应。
PGTunnelServiceImpl.kt：隧道服务的具体实现，封装了隧道连接的核心逻辑。
BootReceiver.java：系统启动时自动启动隧道服务的广播接收器。
AppCtx.java：应用上下文类，初始化隧道服务

## 3.1 问题
#### 4. 客户端和服务端之间的握手连接是如何实现的？在握手过程中，哪些信息需要校验？

#### 5. 提到的“穿透”指的是什么？讲讲 NAT、STUN、TURN

1. **穿透原理**  
   - A 在局域网，B 在另一个局域网，他们都访问一个 **公网服务器 C**，通过 `C` 来协调连接，最终使 A 和 B 建立直连（若失败再用 C 中转）。  

2. **NAT**  
   - 允许多个设备共享一个公共 IP 地址以访问互联网  

3. **STUN**  
   - 允许 NAT 后的设备发现其公共 IP 地址和端口。当两个设备都知道对方的公共 IP 和端口时，它们就可以尝试建立 P2P 连接。  

4. **TURN**  
   - 数据中转站
