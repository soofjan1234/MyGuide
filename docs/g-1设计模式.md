------

# 设计模式

> 作者：hou
------
# 创建型模式

1. **单例模式 (Singleton)**
   - 确保一个类只有一个实例，并提供全局访问点
2. **工厂方法模式 (Factory Method)**
   - 定义一个创建对象的接口，让子类决定实例化哪个类，"单点"：只关心怎么做出一个产品
3. **抽象工厂模式 (Abstract Factory)**
   - 提供一个创建一系列相关或相互依赖对象的接口，"套餐"：关心怎么做出一组配套的产品
4. **建造者模式 (Builder)**
   - 将一个复杂对象的构建与其表示分离
5. **原型模式 (Prototype)**
   - 通过复制现有对象来创建新对象

## 结构型模式

1. **适配器模式 (Adapter)**
   - 将一个类的接口转换成客户希望的另一个接口
2. **桥接模式 (Bridge)**
   - 将抽象部分与实现部分分离，使它们可以独立变化
   - 工厂方法是解决怎么创建对象
   - 桥接模式是解决怎么组合功能
3. **组合模式 (Composite)**
   - 将对象组合成树形结构以表示"部分-整体"的层次结构
4. **装饰器模式 (Decorator)**
   - 动态地给一个对象添加额外的职责
5. **外观模式 (Facade)**
   - 为子系统中的一组接口提供一个统一的接口
6. **享元模式 (Flyweight)**
   - 运用共享技术有效地支持大量细粒度的对象
7. **代理模式 (Proxy)**
   - 就像明星的经纪人一样， 控制和管理对原始对象的访问，数据库的连接池就是一个代理

## 行为模式

1. **责任链模式 (Chain of Responsibility)**
   - 使多个对象都有机会处理请求，公司里的审批流程一样
2. **命令模式 (Command)**
   - 将请求封装为对象，支持请求的排队、记录和撤销
3. **解释器模式 (Interpreter)**
   - 定义语言的文法，并定义一个解释器来解释语言中的句子
4. **迭代器模式 (Iterator)**
   - 提供一种方法顺序访问聚合对象中的各个元素
5. **中介者模式 (Mediator)**
   - 用一个中介对象封装一系列对象的交互
6. **备忘录模式 (Memento)**
   - 捕获对象的内部状态并在对象之外保存这个状态
7. **观察者模式 (Observer)**
   - 定义对象间一对多的依赖关系
8. **状态模式 (State)**
   - 允许对象在内部状态改变时改变它的行为
9. **策略模式 (Strategy)**
   - 定义一系列算法，将每个算法封装起来并使它们可以互换
   - 工厂：生产什么对象（创建）
   - 桥接：用什么组合 （结构）
   - 策略：怎么执行 （行为）
10. **模板方法模式 (Template Method)**
   - 定义算法骨架，将某些步骤延迟到子类实现
11. **访问者模式 (Visitor)**
   - 表示一个作用于某对象结构中的各元素的操作
