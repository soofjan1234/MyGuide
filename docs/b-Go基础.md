------

# 二 Go基础

> 作者：hou

## 2.1 Go的优点是什么

### 2.1.1 天然支持高并发
Go语言通过goroutine和channel机制，提供了轻量级的并发支持。goroutine的创建和调度开销远小于线程，使得Go在处理高并发场景时表现出色。

### 2.1.2 学习成本低，上手快
Go语言的语法简洁，去除了许多复杂的概念（如继承、泛型等），使得开发者可以快速上手并投入生产。

### 2.1.3 性能高
Go语言编译后的二进制文件直接运行在操作系统上，无需虚拟机，执行效率高。同时，Go的垃圾回收机制经过优化，减少了GC带来的性能损耗。

### 2.1.4 编译后二进制包体积小
Go语言编译后的二进制文件不依赖外部库，体积小，便于部署和分发。

## 2.2 切片和数组的区别？

### 2.2.1 长度
- **数组**：长度固定，声明时必须指定长度
- **切片**：长度可变，支持自动扩容

### 2.2.2 声明方式不同
- **数组**：`var arr [5]int`
- **切片**：`var slice []int`

### 2.2.3 内存分配
- **数组**：值类型，在栈上分配内存
- **切片**：引用类型，底层引用数组

### 2.2.4 传递开销
- **数组**：传递时会复制整个数组
- **切片**：仅复制切片头（包含指针、长度和容量）

## 2.3 切片的关键特性、基本属性、注意点

### 2.3.1 底层依赖数组
当切片基于数组创建时，它们会**共享同一块底层内存空间**。这意味着通过切片修改元素会直接影响原始数组，反之亦然。

### 2.3.2 创建方式
- 从数组创建：`slice := arr[start:end]`
- 直接创建：`slice := make([]int, length, capacity)`

### 2.3.3 零值
切片的零值为`nil`，表示未初始化的切片。

### 2.3.4 性能优化
- 一次分配足够空间，避免频繁扩容
- 合理设置容量，减少内存分配次数

## 2.4 如何扩容

### 2.4.1 触发条件
当切片的长度超过容量时，Go会自动触发扩容。

### 2.4.2 扩容算法
1. **小切片(<256元素)**：双倍扩容
2. **大切片(≥256元素)**：平滑过渡到约1.25倍扩容

### 2.4.3 内存对齐、分片
Go在扩容时会考虑内存对齐，以提高访问效率。

### 2.4.4 数据迁移
扩容后，原数据会被复制到新的内存空间。

## 2.5 Go深度拷贝

### 2.5.1 使用json序列化、反序列化
通过json序列化和反序列化实现深度拷贝，但性能较低。

### 2.5.2 gob编码
使用gob编码进行深度拷贝，比json性能更好，可以处理更复杂的类型。

### 2.5.3 第三方库
可以使用`github.com/jinzhu/copier`等第三方库实现深度拷贝。

### 2.5.4 手动实现
对于简单的结构体，可以手动实现深度拷贝方法。